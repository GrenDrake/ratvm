// ////////////////////////////////////////////////////////////////////////////
// Common strings
// ////////////////////////////////////////////////////////////////////////////
value continueStr "Continue"


// ////////////////////////////////////////////////////////////////////////////
// Data used for tests
// ////////////////////////////////////////////////////////////////////////////
value testInt 7384
value testStr "A Name"
value testList [ 1 2 3 ]
value testMap { 1: "The" 2: "End" 3: "Is" 4: "Far" }
value testFunction function testFunctionName () {}
value testObject object testObjectName;
value testProperty $testFunc
value testFlags flags( 6 7 8 testInt )

object first_obj
    anInt 2
    aString "Hello World!"
    aProperty $apple
    anObject object ;
    aMap { $fruit: $apple }
    aList [ 4 ]
    testMethod function() { }
;
object second_obj;


// ////////////////////////////////////////////////////////////////////////////
// Code for testing load/save
// ////////////////////////////////////////////////////////////////////////////

function printMagicNumbers() {
    asm
    "\nThis morning's magic numbers are: " say
    $number1 magic_1 get_prop say ", " say
    $number2 magic_1 get_prop say ", and " say
    $number3 magic_1 get_prop say
    ". This evening's magic numbers are: " say
    $number1 magic_2 get_prop say ", " say
    $number2 magic_2 get_prop say ", and " say
    $number3 magic_2 get_prop say ".\n" say
}

object magic_1
    ident 1
    save function(data) {
        asm
        $number1 self get_prop 99 data add_item
        $number2 self get_prop 99 data add_item
        $number3 self get_prop 99 data add_item
    }
    load function(data) {
        asm
        0 data get_item $number1 self set_prop
        1 data get_item $number2 self set_prop
        2 data get_item $number3 self set_prop
    }
    number1 0
    number2 0
    number3 0
;

object magic_2
    ident 2
    save function(data) {
        asm
        $number1 self get_prop 99 data add_item
        $number2 self get_prop 99 data add_item
        $number3 self get_prop 99 data add_item
    }
    load function(data) {
        asm
        0 data get_item $number1 self set_prop
        1 data get_item $number2 self set_prop
        2 data get_item $number3 self set_prop
    }
    number1 0
    number2 0
    number3 0
;


// ////////////////////////////////////////////////////////////////////////////
// Test stack commands
// ////////////////////////////////////////////////////////////////////////////
function testStack() {
    asm
    2 4 6 8

    "\n# Testing stack manipulation\n" say

    "Testing correct initial size...[br]" say
    stack_size 4 cmp testPeek jz
    "Stack has bad initial size." error

    testPeek:
    "Testing stack peeking...[br]" say
    0 stack_peek 8 cmp testPeek2 jz
    "Failed peek at top item." error
    testPeek2:
    3 stack_peek 2 cmp testPop jz
    "Failed peek at bottom item." error

    testPop:
    "Popping item and checking stack size...[br]" say
    pop
    stack_size 3 cmp testPush jz
    "Stack has bad size after pop." error

    testPush:
    "Pushing new item and checking stack size...[br]" say
    94
    stack_size 4 cmp testDup jz
    "Stack has bad size after push." error

    testDup:
    "Duplicating top item and checking size and value...[br]" say
    stack_dup
    stack_size 5 cmp testDup2 jz
    "Stack has bad size after stack_dup." error
    testDup2:
    cmp testSwap jz
    "Duplicate item not equal to original." error

    testSwap:
    "Testing stack swapping...[br]" say
    0 2 stack_swap
    0 stack_peek 2 cmp testSwapError jnz
    2 stack_peek 6 cmp testSwapError jnz

    return

    testSwapError:
    "Stack swap failed." error
}


// ////////////////////////////////////////////////////////////////////////////
// Test function calls and arguments
// ////////////////////////////////////////////////////////////////////////////
function testCall() {
    asm
    "\n# Testing function calls\n" say

    "Checking value of self on non-method...[br]" say
    self none cmp oneUnspecified jz
    "Incorrect value of self." error

    oneUnspecified:
    "Testing call with unspecified arguments...[br]" say
    24 1 testCall_onlyOne call

    "Testing call with extra arguments...[br]" say
    34 88 24 3 testCall_both call

    "Checking result of calling testCallHelperMultiply(5,6)...[br]" say
    5 6 2 testCallHelperMultiply call 30 cmp testMethodCall jz
    "testCallHelperMultiply(5,6) did not have result of 30." error

    testMethodCall:
    "Calling testCallObject.testMethod...[br]" say
    3 2 1 3 $testMethod testCallObject call_method
}

object testCallObject
    testMethod function(arg1 arg2 arg3) {
        asm

        "[i]testMethod:[/i] Checking value of self...[br]" say
        self testCallObject cmp testArg1 jz
        "Incorrect value of self." error

        testArg1:
        "[i]testMethod:[/i] Checking argument values...[br]" say
        arg1 1 cmp testArg2 jz
        "First argument has wrong value." error
        testArg2:
        arg2 2 cmp testArg3 jz
        "Second argument has wrong value." error
        testArg3:
        arg3 3 cmp done jz
        "Third argument has wrong value." error

        done:
    }
;

function testCall_onlyOne( arg1 arg2 ) {
    asm

    arg1 none cmp compareArg2 jnz
    "First passed argument had unexpected none" error

    compareArg2:
    arg2 none cmp done jz
    "Second passed argument not none" error

    done:
}

function testCall_both( arg1 arg2 : var1 ) {
    asm

    arg1 none cmp compareArg2 jnz
    "First passed argument had unexpected none" error

    compareArg2:
    arg2 none cmp compareVar1 jnz
    "First passed argument had unexpected none" error

    compareVar1:
    var1 none cmp done jz
    "First non-argument local not none" error

    done:
}

function testCallHelperMultiply( arg1 arg2 ) {
    asm arg1 arg2 mult return
}


// ////////////////////////////////////////////////////////////////////////////
// Test compare command
// ////////////////////////////////////////////////////////////////////////////
function testCompare(: testValue) {
    asm
    "\n# Testing compare opcode\n" say

    "Comparing integer values...[br]" say
    5 5 cmp testCmpLT jz
    "Failed 5 == 5." error

    testCmpLT:
    2 5 cmp testCmpGT jlt
    "Failed 2 < 5." error

    testCmpGT:
    5 2 cmp testCmpLTE jgt
    "Failed 5 > 2." error

    testCmpLTE:
    2 5 cmp testCmpLTE2 jlte
    "Failed 2 <= 5." error

    testCmpLTE2:
    5 5 cmp testCmpGTE jlte
    "Failed 5 <= 5." error

    testCmpGTE:
    5 2 cmp testCmpGTE2 jgte
    "Failed 5 >= 2." error

    testCmpGTE2:
    5 5 cmp testCmpLtNeg jgte
    "Failed 5 >= 5." error

    testCmpLtNeg:
    -5 5 cmp testCmpGtNeg jlt
    "Failed -5 < 5." error

    testCmpGtNeg:
    5 -5 cmp testNonInteger jgt
    "Failed 5 > -5." error


    testNonInteger:
    "Testing non-integer comparisons...[br]" say
    none none cmp testStrNone jz
    "Failed none == none." error

    testStrNone:
    "\n" none cmp testStrFunc jnz
    "Failed String != none." error

    testStrFunc:
    "\n" testCompare cmp testStrSelf jnz
    "Failed String != Function." error

    testStrSelf:
    "\n" "\n" cmp testStrStr jz
    "Failed String != self." error

    testStrStr:
    "\n" " " cmp testWithLocals jnz
    "Failed String != String." error

    testWithLocals:
    "Testing using local variables...[br]" say
    5 testValue store
    testValue 5 cmp localLt jz
    "Failed local == 5." error

    localLt:
    2 testValue cmp localGt jlt
    "Failed 2 < local." error

    localGt:
    testValue 2 cmp done jgt
    "Failed local > 2." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test jump commands
// ////////////////////////////////////////////////////////////////////////////
function testJumps(: testValue) {
    asm
    "\n# Testing jump opcodes\n" say

    "Testing unconditional jump...[br]" say
    test001 jmp
    "Failed unconditional jump." error

    test001:
    "Testing conditional jumps...[br]" say
    0 test002 jz
    "Failed jz (0)." error

    test002:
    1 test002_failed jz
    test003 jmp
    test002_failed:
    "Failed jz (1)." error

    test003:
    0 test003_failed jnz
    test004 jmp
    test003_failed:
    "Failed jnz (0)." error

    test004:
    1 test005 jnz
    "Failed jnz (1)." error

    test005:
    1 test005_failed jlt
    test006 jmp
    test005_failed:
    "Failed jlt (1)." error

    test006:
    0 test006_failed jlt
    test007 jmp
    test006_failed:
    "Failed jlt (0)." error

    test007:
    -1 test008 jlt
    "Failed jlt (-1)." error

    test008:
    -1 test008_failed jgt
    test009 jmp
    test008_failed:
    "Failed jgt (-1)." error

    test009:
    0 test009_failed jgt
    test010 jmp
    test009_failed:
    "Failed jgt (0)." error

    test010:
    1 test011 jgt
    "Failed jgt (1)." error

    test011:
    -1 test012 jlte
    "Failed jlte (-1)." error

    test012:
    0 test013 jlte
    "Failed jlte (0)." error

    test013:
    1 test013_failed jlte
    test014 jmp
    test013_failed:
    "Failed jlte (1)." error

    test014:
    1 test015 jgte
    "Failed jgte (1)." error

    test015:
    0 test016 jgte
    "Failed jgte (0)." error

    test016:
    -1 test016_failed jgte
    test017 jmp
    test016_failed:
    "Failed jgte (-1)." error

    test017:
    "Test jump target in local variable...[br]" say
    test018 testValue store
    testValue jmp
    "Failed jmp w/ local." error

    test018:
    test019 testValue store
    0 testValue jz
    "Failed jz w/ local." error

    test019:
    test020 testValue store
    1 testValue jnz
    "Failed jnz w/ local." error

    test020:
    test021 testValue store
    -1 testValue jlt
    "Failed jlt w/ local." error

    test021:
    test022 testValue store
    1 testValue jgt
    "Failed jgt w/ local." error

    test022:
    test023 testValue store
    -1 testValue jlte
    "Failed jlte w/ local." error

    test023:
    test024 testValue store
    1 testValue jgte
    "Failed jgte w/ local." error

    test024:
    "Testing with value in local variable...[br]" say
    0 testValue store
    testValue test025 jz
    "Failed jz w/ value in local." error

    test025:
    1 testValue store
    testValue test026 jnz
    "Failed jnz w/ value in local." error

    test026:
    testValue test027 jgt
    "Failed jgt w/ value in local." error

    test027:
    testValue test028 jgte
    "Failed jgte w/ value in local." error

    test028:
    -1 testValue store
    testValue test029 jlt
    "Failed jlt w/ value in local." error

    test029:
    testValue done jlte
    "Failed jlte w/ value in local." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test math commands
// ////////////////////////////////////////////////////////////////////////////
function testMath(: counter) {
    asm

    "\n## Testing math opcodes\n" say
    " 5 + 5 = " say
    5 5 add say
    "\n" say

    "10 - 5 = " say
    10 5 sub say
    "\n" say

    " 5 * 5 = " say
    5 5 mult say
    "\n" say

    "40 / 5 = " say
    40 5 div say
    "\n" say

    "40 % 6 = " say
    40 6 mod say
    "\n" say

    "2 ^ 8 = " say
    2 8 pow say
    "\n" say

    "1 << 4 = " say
    1 4 left_shift say
    "\n" say

    "32 >> 4 = " say
    32 4 right_shift say
    "\n" say

    "86 & 90 = " say
    86 90 bit_and say
    "\n" say

    "30 | 13 = " say
    30 13 bit_or say

    "\n28 xor 23 = " say
    28 23 bit_xor say

    "\n~348 = " say
    348 bit_not say

    "\nDec test:" say
    4 counter store
    dectestloop:
    " " say counter say
    counter dec counter store
    counter 0 cmp dectestloop jgte

    "[br]Inc test:" say
    0 counter store
    inctestloop:
    " " say counter say
    counter inc counter store
    counter 4 cmp inctestloop jlte

    "\nNot 0: " say 0 not say "[br]" say
    "Not 1: " say 1 not say "[br]" say
    "Not 37: " say 37 not say "[br]" say
    "Not -9: " say -9 not say "[br]" say
    "Not \"Fred\": " say "Fred" not say "[br]" say
    "Not testMath: " say testMath not say "[br]" say
    "Not none: " say none not say "[br]" say
}


// ////////////////////////////////////////////////////////////////////////////
// Test object property commands
// ////////////////////////////////////////////////////////////////////////////
function testObjectProps() {
    asm

    "\n# Testing object manipulation opcodes\n[b][testing get_prop][/b][br]" say
    "first_obj.aString: " say
    $aString first_obj get_prop say
    " (should be \"Hello World!\")[br]" say

    "first_obj.anInt: " say
    $anInt first_obj get_prop say
    " (should be 2)[br]" say

    "second_obj.aString: " say
    $aString second_obj get_prop say
    " (should be 0)[br]" say

    "\n[b][testing has_prop][/b][br]" say
    "first_obj has property anInt? " say
    $anInt first_obj has_prop say
    " (should be 1)[br]" say

    "second_obj has property aString? " say
    $aString second_obj has_prop say
    " (should be 0)[br]" say

    "\n[b][testing set_prop][/b][br]" say
    "setting second_obj.apple to \"Fred\"[br]second_obj.apple now equals " say
    "Fred" $apple second_obj set_prop
    $apple second_obj get_prop say

    "\n[b][testing property types][/b]" say
    "[br]first_obj.anInt (1): "      say $anInt      first_obj get_prop typeof say
    "[br]first_obj.aString (2): "    say $aString    first_obj get_prop typeof say
    "[br]first_obj.aList (3): "      say $aList      first_obj get_prop typeof say
    "[br]first_obj.aMap (4): "       say $aMap       first_obj get_prop typeof say
    "[br]first_obj.testMethod (5): " say $testMethod first_obj get_prop typeof say
    "[br]first_obj.anObject (6): "   say $anObject   first_obj get_prop typeof say
    "[br]first_obj.aProperty (7): "  say $aProperty  first_obj get_prop typeof say
}


// ////////////////////////////////////////////////////////////////////////////
// Basic looping demo
// ////////////////////////////////////////////////////////////////////////////
function testLoopDemo(: counter theValue) {
    asm
// show a count up loop and calculate 2^10
    0 counter store
    1 theValue store
    loopstart:
    counter 1 add counter store
    2 theValue mult theValue store
    counter say
    " " say
    counter 10 cmp loopstart jlt
    "Loop finished!\n" say
    "Final result: " say
    theValue say
    "\n" say
}


// ////////////////////////////////////////////////////////////////////////////
// Test input commands
// ////////////////////////////////////////////////////////////////////////////
function testInputs() {
    asm
    "This node serves as a test of the menu selection options. Other input options can be selected in the menu below, or you can return to the top level menu." say
    "Test key input"        testGetkey     add_option
    "No extra value"        receiveExtra   add_option
    "Extra value 6"         receiveExtra   6   add_option_x
    "Extra value 73"        receiveExtra   73  add_option_x
    dispatcher get_option
}
function receiveExtra(extra) {
    asm
    "Option extra value: " say extra say
    "Back to inputs menu" testInputs add_option
    dispatcher get_option
}
function testGetkey() {
    asm
    "This will demonstrate and test the get_key input type." say
    "Try pressing a key." testGetkeyReceive get_key
}
function testGetkeyReceive(key) {
    asm
    "Resulting character code: " say key say ".\n" say
    "Back to inputs menu" testInputs add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test value types
// ////////////////////////////////////////////////////////////////////////////
function testValues(: localvar unusedvar) {
    asm

    "int value: " say testInt typeof say
    testInt typeof Integer cmp int_bad jnz
    " good[br]" say tst_string jmp
    int_bad: " wrong[br]" say

    tst_string:
    "string value: " say testStr typeof say " " say
    testStr typeof String cmp string_bad jnz
    " good[br]" say tst_list jmp
    string_bad: " wrong[br]" say

    tst_list:
    "list value: " say testList typeof say " " say
    testList typeof List cmp list_bad jnz
    " good[br]" say tst_map jmp
    list_bad: " wrong[br]" say

    tst_map:
    "map value: " say testMap typeof say " " say
    testMap typeof Map cmp map_bad jnz
    " good[br]" say tst_function jmp
    map_bad: " wrong[br]" say

    tst_function:
    "function value: " say testFunction typeof say " " say
    testFunction typeof Function cmp function_bad jnz
    " good[br]" say tst_function_2 jmp
    function_bad: " wrong[br]" say
    tst_function_2:
    "value function aliasing:" say
    testFunction testFunctionName cmp tst_function_2_bad jnz
    " good[br]" say tst_obj jmp
    tst_function_2_bad: " wrong[br]" say

    tst_obj:
    "object value: " say testObject typeof say " " say
    testObject typeof Object cmp obj_bad jnz
    " good[br]" say tst_obj_2 jmp
    obj_bad: " wrong[br]" say
    tst_obj_2:
    "value object aliasing:" say
    testObject testObjectName cmp test_obj_2_bad jnz
    " good[br]" say tst_prop jmp
    test_obj_2_bad: " wrong[br]" say

    tst_prop:
    "property value: " say testProperty typeof say " " say
    testProperty typeof Property cmp prop_bad jnz
    " good[br]" say tst_flags jmp
    prop_bad: " wrong[br]" say

    tst_flags:
    "flagset value: " say testFlags typeof say " " say
    testFlags typeof Integer cmp flags_bad jnz
    " good\n" say tst_local jmp
    flags_bad: " wrong\n" say

    tst_local:
    "[b][setting local variable \"localvar\" to 57][/b][br]" say
    57 localvar store
    "local variable value: (" say localvar say ") " say localvar typeof say " " say
    localvar typeof Integer cmp local_bad jnz
    " good[br]" say tst_unused jmp
    local_bad: " wrong[br]" say

    tst_unused:
    "unused local value: (" say unusedvar say ") " say
    unusedvar typeof say " " say
    unusedvar typeof None cmp unused_bad jnz
    " good[br]" say tst_jump jmp
    unused_bad: " wrong[br]" say

    tst_jump:
    "jump target value: " say tst_jump typeof say
    tst_jump typeof Label cmp label_bad jnz
    " good\n" say all_done jmp
    label_bad: " wrong\n" say

    "[b][type coercion][/b][br]" say
    7 localvar store
    "Initial value: " say localvar say " and type: " say localvar typeof say "[br]" say
    String localvar astype localvar store
    "New value: \"" say localvar say "\" and type: " say localvar typeof say "[br]" say

    all_done:
}

// ////////////////////////////////////////////////////////////////////////////
// Output command tests
// ////////////////////////////////////////////////////////////////////////////
function testOutput() {
    asm

    "This text (and nearly all text in these tests) is output using the \"say\" command.\nSay integer value: " say
    6215 say
    "[br]-1 using say_unsigned (should be 4294967295): " say
    -1 say_unsigned
    "[br] using say_char (should be 'A'): " say
    65 say_char
    "[br]Say UTF-8 Text: テキストの例\n" say

    "Horizontal rule below this:\n---\nTest below horizontal rule.\n" say

    "# Testing text formatting:\n" say
    "bold text: [b]Lorem ipsum dolor sit amet.[/b][br]" say
    "italic text: [i]Lorem ipsum dolor sit amet.[/i][br]" say
    "bold italic: [b][i]Lorem ipsum dolor sit amet.[/i][/b][br]" say
    "italic bold: [i][b]Lorem ipsum dolor sit amet.[/b][/i]\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Update info areas
// ////////////////////////////////////////////////////////////////////////////
function testInfoarea() {
    asm

    "The header, footer, and title regions should now be updated. (Unless you already ran this test since starting the program.)" say

    "Good day!"     InfobarLeft     set_info
    "5:00 am"       InfobarRight    set_info
    "Fred is Cool"  InfobarFooter   set_info
    "Updated Title" InfobarTitle    set_info
}

// ////////////////////////////////////////////////////////////////////////////
// Test RNG
// ////////////////////////////////////////////////////////////////////////////
function testRandom(: counter) {
    asm

    "This will generate 100 random numbers between 50 and 60 below.\n" say

    100 counter store
    loop_start:
    counter loop_done jlte
    50 60 random say " " say
    counter 1 sub counter store
    loop_start jmp
    loop_done: "\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Test List Methods
// ////////////////////////////////////////////////////////////////////////////
function printArray(theArray : counter length) {
    asm

    "[b]Array contents:[/b]" say
    theArray get_size length store
    0 counter store
    arraydumploop:
    " " say counter theArray get_item say
    counter inc counter store
    length counter cmp arraydumploop jgt
    " (length: " say length say ")\n" say
}

function testLists(: counter) {
    asm

    "Test list size (should be 3): " say
    testList get_size say "\n" say
    testList 1 printArray call

    "Adding new item 91 at end...\n" say
    91 99 testList add_item "\n" say
    testList 1 printArray call

    "Adding new item 4608 in first position...\n" say
    4608 0 testList add_item "\n" say
    testList 1 printArray call

    "Adding new item 44 after second item...\n" say
    44 2 testList add_item "\n" say
    testList 1 printArray call

    "New test list size (should be 6): " say
    testList get_size say "\n" say

    "Deleting index #2...\n" say
    2 testList del_item
    testList 1 printArray call

    "Trying to get bad index -1: " say
    -1 testList get_item say "\n" say

    "Trying to get bad index 99: " say
    99 testList get_item say "\n" say

    "Updating index #2 to second_obj...\n" say
    second_obj 2 testList set_item
    testList 1 printArray call

    "\nSelecting 20 random items from testList:" say
    0 counter store
    randomloop:
    " [" say testList get_random say "]" say
    counter inc counter store
    20 counter cmp randomloop jgt
}

// ////////////////////////////////////////////////////////////////////////////
// Test Map Methods
// ////////////////////////////////////////////////////////////////////////////
function testMaps(: keys) {
    asm

    "Current item \"7\" (non-existant key): " say
    7 testMap get_item say
    "[br]" say


    "Current item \"2\" (\"End\"): " say
    2 testMap get_item say
    "\n" say

    "Updating item \"2\"...[br]" say
    "Apple" 2 testMap set_item

    "New item \"2\" (\"Apple\"): " say
    2 testMap get_item say
    "\n" say


    "Adding item \"item\"...[br]" say
    "newkey" "item" testMap set_item

    "Item \"item\" value (\"newkey\"): " say
    "item" testMap get_item say
    "[br]" say


    "Has key 2 (yes): " say
    2 testMap has_item say
    "\n" say

    "Deleting item \"2\"...[br]" say
    2 testMap del_item
    "Current item \"2\" (\"End\"): " say
    2 testMap get_item say "\n" say

    "Has key 2 (no): " say
    2 testMap has_item say
    "[br]" say


    "Has key 3 (yes): " say
    3 testMap has_item say
    "[br]" say

    "Has key 88 (no): " say
    88 testMap has_item say
    "\n" say

    testMap get_keys keys store
    "Converting testMap keys to list...[br]" say
    keys 1 printArray call
}

// ////////////////////////////////////////////////////////////////////////////
// Test Page Commands
// ////////////////////////////////////////////////////////////////////////////
function testPages() {
    asm
    "Demo Page" testPage1 'd' add_page
    "Another Page" otherPage 'a' add_page
    "Page" otherPage 'p' add_page
    "A Long Page Name" otherPage 'l' add_page
    0 testPagesReal call
}
function testPagesReal() {
    asm
    "Extra pages have been added and can be activated by hotkey or by clicking on their button in the lower left." say
    "Remove \"Another Page\"" testPagesRemovePage add_option
    "Cleanup and return to main list" testPagesCleanup add_option
    dispatcher get_option
}
function testPagesRemovePage() {
    asm
    "Another Page" del_page
    0 testPagesReal call
}
function testPagesCleanup() {
    asm
    "Demo Page" del_page
    "Another Page" del_page
    "Page" del_page
    "A Long Page Name" del_page
    0 showOptions call
}

object testpageData
    count 1
    index 0
;
function testPage1(key) {
    asm
    key typeof Integer cmp showpage jnz
    key 32 cmp showkey jnz
    end_page
    return

    leftkey:
    $index testpageData get_prop dec $index testpageData set_prop
    showpage jmp
    rightkey:
    $index testpageData get_prop inc $index testpageData set_prop
    showpage jmp
    upkey:
    $index testpageData get_prop 10 mult $index testpageData set_prop
    showpage jmp
    downkey:
    $index testpageData get_prop 10 div $index testpageData set_prop
    showpage jmp

    showkey:
    "You pressed: " say key say " (which is not space).\n" say
    key -1 cmp leftkey jz
    key -2 cmp rightkey jz
    key -3 cmp downkey jz
    key -4 cmp upkey jz
    showpage:
    "You have viewed this page " say
    $count testpageData get_prop say
    " times. The index counter is " say
    $index testpageData get_prop say
    ". Use arrow keys to change."
    "Press space to return." testPage1 get_key
    $count testpageData get_prop inc $count testpageData set_prop
}
function otherPage() {
    asm
    "You selected a page other than the demo page! (Only the demo page has actual content.)" say
    "Continue" none add_option
    endOtherPage get_option
}
function endOtherPage() {
    asm end_page
}

// ////////////////////////////////////////////////////////////////////////////
// Test Dynamic Creation
// ////////////////////////////////////////////////////////////////////////////
function testDynamic(: newObj newStr newList newMap) {
    asm

    "[b]Creating data...[/b][br]" say

    "[i]Creating new object...[/i][br]" say
    Object new newObj store
    "Created type:" say newObj typeof say "[br]" say

    "Initial anInt property: " say
    $anInt newObj get_prop say "[br]" say
    66 $anInt newObj set_prop
    "anInt property after update: " say
    $anInt newObj get_prop say "\n" say

    "[i]Creating new string...[/i][br]" say
    String new newStr store
    "Created type:" say newStr typeof say "[br](string manipulation functions tested seperately)\n" say

    "[i]Creating new map...[/i][br]" say
    Map new newMap store
    "Created type:" say newMap typeof say "[br]" say
    "Initial value of key: " say "key" newMap get_item say "[br]" say
    "New Map Value" "key" newMap set_item
    "Updated value of key: " say "key" newMap get_item say "\n" say

    "[i]Creating new list...[/i][br]" say
    List new newList store
    "Created type:" say newList typeof say "[br]" say
    "Initial size: " say newList get_size say "[br]" say
    "New List Item" 0 newList add_item
    "New size: " say newList get_size say "[br]" say
    "Item 0: " say 0 newList get_item say "\n" say

    "[b]Testing isStatic[/b][br]" say
    "testDynamic (1): " say testDynamic is_static say "[br]" say
    "\"Fred\" (1): " say "Fred" is_static say "[br]" say
    "testList (1): " say testList is_static say "[br]" say
    "newObj (0):" say newObj is_static say "[br]" say
    "newStr (0):" say newStr is_static say "\n" say

    List new List new List new say
}

// ////////////////////////////////////////////////////////////////////////////
// Test String Manipulation
// ////////////////////////////////////////////////////////////////////////////
function testStringManipulation(: testString) {
    asm

    "\n# Test String Manipulation\n" say

    "Check static string \"Fred\" has length four...[br]" say
    "Fred" strlen 4 cmp strlenNewString jz
    "Bad length on static string \"Fred\"." error

    strlenNewString:
    String new testString store
    "Check new string has zero length...[br]" say
    testString strlen strcpyStrlen jz
    "Bad initial length on new string." error

    strcpyStrlen:
    "Copying \"Fred\" to dynamic string...[br]" say
    "Fred" testString strcpy
    testString strlen 4 cmp stringCompares jz
    "Bad length on copied string \"Fred\"." error

    stringCompares:
    "Comparing static and dynamic strings with [b]==[/b]...[br]" say
    testString "Fred" cmp stringCompareStrcmp jnz
    "Identity of dynamic and static strings compared equal." error

    stringCompareStrcmp:
    "Comparing static and dynamic strings with [b]strcmp[/b]...[br]" say
    "Fred" testString strcmp stringAppend jz
    "Dynamic and static strings did not compare equal." error

    stringAppend:
    "Appending to test string...[br]" say
    " Lives!" testString strcat
    "Fred Lives!" testString strcmp doneStrings jz
    "String append malfunctioned." error

    doneStrings:
}

// ////////////////////////////////////////////////////////////////////////////
// All tests runner
// ////////////////////////////////////////////////////////////////////////////
function doAllTests() {
    asm

    0 testJumps call
    0 testCompare call
    0 testCall call
    0 testStack call
    0 testMath call

    0 testValues call
    0 testLists call
    0 testMaps call
    0 testObjectProps call
    0 testDynamic call
    0 testStringManipulation call

    0 testOutput call
    0 testInfoarea call
    0 testRandom call
}

// ////////////////////////////////////////////////////////////////////////////
// Test selection
// ////////////////////////////////////////////////////////////////////////////
function showOptions() {
    asm

    true saveAllowed set_setting
    "Welcome to the feature test demo!\nSelect one of the options displayed below by entering its associated number in order to run the tests. When that is complete, you will be returned to this screen. The magic numbers below will are randomized every time you start the game, but will be maintained across saving and loading." say
    0 printMagicNumbers call

    "All non-interactive tests" doAllTests         add_option
    "Loop demo"                 testLoopDemo       add_option

    "Test jumps"                testJumps          add_option
    "Test compare"              testCompare        add_option
    "Test call"                 testCall           add_option
    "Test stack commands"       testStack          add_option
    "Test math"                 testMath           add_option

    "Test value types"          testValues         add_option
    "Test list methods"         testLists          add_option
    "Test map methods"          testMaps           add_option
    "Test object properties"    testObjectProps    add_option
    "Test dynamic objects"      testDynamic        add_option
    "Test string manipulation"  testStringManipulation  add_option

    "Test output"               testOutput         add_option
    "Test info areas"           testInfoarea       add_option
    "Test random"               testRandom         add_option

    "Test pages"                testPages          add_option
    "Test input methods"        testInputs         add_option
    dispatcher get_option
}


function dispatcher(optionFunc extraValue) {
    asm

    false saveAllowed set_setting
    extraValue 1 optionFunc call

    optionFunc showOptions cmp alldone jz
    optionFunc testPages cmp alldone jz
    optionFunc testPagesReal cmp alldone jz
    optionFunc testPagesRemovePage cmp alldone jz
    optionFunc receiveExtra cmp alldone jz
    optionFunc testGetkey cmp alldone jz
    "Return to main page" showOptions add_option
    dispatcher get_option

    alldone:
    0 return
}

function main(fromRestore) {
    asm
    "GTRPGE Test Suite" InfobarTitle set_info
    fromRestore all_done jnz

    // set the "magic numbers" used for demonstrate the load/save code
    10000 40000 random $number1 magic_1 set_prop
    10000 40000 random $number2 magic_1 set_prop
    10000 40000 random $number3 magic_1 set_prop
    10000 40000 random $number1 magic_2 set_prop
    10000 40000 random $number2 magic_2 set_prop
    10000 40000 random $number3 magic_2 set_prop

    all_done:
    0 showOptions call
}

value te ""
