// ////////////////////////////////////////////////////////////////////////////
// Common strings
// ////////////////////////////////////////////////////////////////////////////
value continueStr "Continue";


// ////////////////////////////////////////////////////////////////////////////
// Data used for tests
// ////////////////////////////////////////////////////////////////////////////
value testInt 7384;
value testStr "A Name";
value testList [ 1 2 3 ];
value testMap { 1: "The" 2: "End" 3: "Is" 4: "Far" };
value testFunction function testFunctionName () {};
value testObject object testObjectName;; // double semicolon currently required
value testProperty $testFunc;

object first_obj
    anInt 2
    aString "Hello World!"
    aProperty $apple
    anObject object ;
    aMap { $fruit: $apple }
    aList [ 4 ]
    testMethod function(arg1 arg2 arg3) {
        asm
        "I am: " say self say "\n" say
        "My Arguments: " say
        arg1 say ", " say
        arg2 say ", " say
        arg3 say "\n" say
    }
;
object second_obj;


// ////////////////////////////////////////////////////////////////////////////
// Test stack commands
// ////////////////////////////////////////////////////////////////////////////
function testStack() {
    asm
    2 4 6 8

    "\n## Testing stack manipulation\n" say
    "Items on Stack: " say
    stack_size say
    " (should be 4)\nPopping.\n" say
    pop
    "New items on Stack: " say
    stack_size say
    " (should be 3)\n" say
    pop

    stack_dup
    "Stackdup: " say say ", " say say " (should be 4, 4)\n" say

    5 6 7 8 2 stack_peek
    "Stack peek: " say say " (should be 6)\n" say

    continueStr showOptions add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test function calls and arguments
// ////////////////////////////////////////////////////////////////////////////
function testCall() {
    asm

    "\n## Testing function calls\n" say
    "Passing (4, 5). " say
    5 4 2 testCallHelper call
    "Passing (4). " say
    4 1 testCallHelper call
    "Passing (). " say
    0 testCallHelper call
    "Multiply 5 * 5 = " say
    5 5 2 testCallHelperMultiply call say
    "\n" say

    "[b]Calling first_obj.testMethod...[/b]\n" say
    3 2 1 3 $testMethod first_obj call_method

    continueStr showOptions add_option
    dispatcher get_option
}

function testCallHelper( arg1 arg2 ) {
    asm

    "Received: (" say
    arg1 say
    ", " say
    arg2 say
    ")\n" say
}

function testCallHelperMultiply( arg1 arg2 ) {
    asm arg1 arg2 mult return
}


// ////////////////////////////////////////////////////////////////////////////
// Test compare command
// ////////////////////////////////////////////////////////////////////////////
function testCompare(: testValue) {
    asm
    "\n# Testing compare opcode\n" say

    "[b][comparing integer values][/b][br]" say
    " 5 vs 5 (=   0): " say 5 5  cmp say "[br]" say
    " 2 < 5: " say 2 5 cmp testLTgood jlt
        " [b]failed[/b][br]" say testGT jmp
        testLTgood: " passed[br]" say
    testGT:
    " 5 < 2: " say 5 2 cmp testGTgood jgt
        " [b]failed[/b][br]" say testGT jmp
        testGTgood: " passed[br]" say
    "-5 vs 5 (= -10): " say -5 5 cmp say "[br]" say
    "5 vs -5 (=  10): " say 5 -5 cmp say "\n" say

    "\n[b][comparing non-integer values][/b][br]" say
    "none vs none (= 0): " say testValue none cmp say "[br]" say
    "string vs none (= 1): " say "\n" none cmp say "[br]" say
    "string vs function (= 1): " say "\n" testCompare cmp say "[br]" say
    "string vs same string (= 0): " say "\n" "\n" cmp say "[br]" say
    "string vs other string (= 1): " say "\n" "" cmp say "\n" say

    "\n[b][testing integer comparisons using local variables][/b][br]" say
    5 testValue store
    " var vs 5 (=  0): " say testValue 5 cmp say "[br]" say
    " 2 vs var (= -3): " say 2 testValue cmp say "[br]" say
    " var vs 2 (=  3): " say testValue 2 cmp say "\n" say

    continueStr showOptions add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test jump commands
// ////////////////////////////////////////////////////////////////////////////
function testJumps(: testValue) {
    asm
    "\n## Testing jump opcodes\n" say

// jump
    "jmp      : " say
    test001 jmp
    "Failed!\n" say 0 return // abort because the rest of the tests depend on
                             // the jmp opcode
    test001: "Succeeded!\n" say

// jump zero
    "jz    (0): " say
    0 test003 jz
    "Failed!\n" say test003after jmp
    test003: "Succeeded!\n" say
    test003after:

    "jz    (1): " say
    1 test004failed jz
    "Succeeded!\n" say test004after jmp
    test004failed: "Failed!\n" say
    test004after:

//  jump not zero
    "jnz   (0): " say
    0 test005failed jnz
    "Succeeded!\n" say test005after jmp
    test005failed: "Failed!\n" say
    test005after:

    "jnz   (1): " say
    1 test006 jnz
    "Failed!\n" say test006after jmp
    test006: "Succeeded!\n" say
    test006after:

//  jump less than
    "jlt   (1): " say
    1 test007failed jlt
    "Succeeded!\n" say test007after jmp
    test007failed: "Failed!\n" say
    test007after:

    "jlt   (0): " say
    0 test008failed jlt
    "Succeeded!\n" say test008after jmp
    test008failed: "Failed!\n" say
    test008after:

    "jlt  (-1): " say
    -1 test009 jlt
    "Failed!\n" say test009after jmp
    test009: "Succeeded!\n" say
    test009after:

//  jump less than or equal
    "jlte  (1): " say
    1 test010failed jlte
    "Succeeded!\n" say test010after jmp
    test010failed: "Failed!\n" say
    test010after:

    "jlte  (0): " say
    0 test011 jlte
    "Failed!\n" say test011after jmp
    test011: "Succeeded!\n" say
    test011after:

    "jlte (-1): " say
    -1 test012 jlte
    "Failed!\n" say test012after jmp
    test012: "Succeeded!\n" say
    test012after:

//  jump greater than
    "jgt   (1): " say
    1 test013 jgt
    "Failed!\n" say test013after jmp
    test013: "Succeeded!\n" say
    test013after:

    "jgt   (0): " say
    0 test014failed jgt
    "Succeeded!\n" say test014after jmp
    test014failed: "Failed!\n" say
    test014after:

    "jgt  (-1): " say
    -1 test015failed jgt
    "Succeeded!\n" say test015after jmp
    test015failed: "Failed!\n" say
    test015after:

//  jump greater than or equal
    "jgte  (1): " say
    1 test016 jgte
    "Failed!\n" say test013after jmp
    test016: "Succeeded!\n" say
    test016after:

    "jgte  (0): " say
    0 test017 jgte
    "Failed!\n" say test017after jmp
    test017: "Succeeded!\n" say
    test017after:

    "jgte (-1): " say
    -1 test018failed jgte
    "Succeeded!\n" say test018after jmp
    test018failed: "Failed!\n" say
    test018after:


    "\n[Jump target stored in local variable.]\n" say
    "jmp: " say
    test019 testValue store
    testValue jmp
    "Failed!\n" say test019after jmp
    test019: "Succeeded!\n" say
    test019after:

    "jz: " say
    test020 testValue store
    0 testValue jz
    "Failed!\n" say test020after jmp
    test020: "Succeeded!\n" say
    test020after:

    "jnz: " say
    test021 testValue store
    1 testValue jnz
    "Failed!\n" say test021after jmp
    test021: "Succeeded!\n" say
    test021after:

    "jlt: " say
    test022 testValue store
    -1 testValue jlt
    "Failed!\n" say test022after jmp
    test022: "Succeeded!\n" say
    test022after:

    "jlte: " say
    test023 testValue store
    -1 testValue jlte
    "Failed!\n" say test023after jmp
    test023: "Succeeded!\n" say
    test023after:

    "jgt: " say
    test024 testValue store
    1 testValue jgt
    "Failed!\n" say test024after jmp
    test024: "Succeeded!\n" say
    test024after:

    "jgte: " say
    test025 testValue store
    1 testValue jgte
    "Failed!\n" say test025after jmp
    test025: "Succeeded!\n" say
    test025after:


    "\n[Test value stored in local variable.]\n" say
    "jz: " say
    0 testValue store
    testValue test026success jz
    "Failed!\n" say test026after jmp
    test026success: "Succeeded!\n" say
    test026after:

    "jnz: " say
    1 testValue store
    testValue test027success jnz
    "Failed!\n" say test027after jmp
    test027success: "Succeeded!\n" say
    test027after:

    "jlt: " say
    -1 testValue store
    testValue test028success jlt
    "Failed!\n" say test028after jmp
    test028success: "Succeeded!\n" say
    test028after:

    "jlte: " say
    -1 testValue store
    testValue test029success jlte
    "Failed!\n" say test029after jmp
    test029success: "Succeeded!\n" say
    test029after:

    "jgt: " say
    1 testValue store
    testValue test030success jgt
    "Failed!\n" say test030after jmp
    test030success: "Succeeded!\n" say
    test030after:

    "jgte: " say
    1 testValue store
    testValue test031success jgte
    "Failed!\n" say test031after jmp
    test031success: "Succeeded!\n" say
    test031after:


    continueStr showOptions add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test math commands
// ////////////////////////////////////////////////////////////////////////////
function testMath(: counter) {
    asm

    "\n## Testing math opcodes\n" say
    " 5 + 5 = " say
    5 5 add say
    "\n" say

    "10 - 5 = " say
    10 5 sub say
    "\n" say

    " 5 * 5 = " say
    5 5 mult say
    "\n" say

    "40 / 5 = " say
    40 5 div say
    "\n" say

    "40 % 6 = " say
    40 6 mod say
    "\n" say

    "2 ^ 8 = " say
    2 8 pow say
    "\n" say

    "1 << 4 = " say
    1 4 left_shift say
    "\n" say

    "32 >> 4 = " say
    32 4 right_shift say
    "\n" say

    "86 & 90 = " say
    86 90 bit_and say
    "\n" say

    "30 | 13 = " say
    30 13 bit_or say

    "\n28 xor 23 = " say
    28 23 bit_xor say

    "\n~348 = " say
    348 bit_not say

    "\nDec test:" say
    4 counter store
    dectestloop:
    " " say counter say
    counter dec counter store
    counter 0 cmp dectestloop jgte

    "[br]Inc test:" say
    0 counter store
    inctestloop:
    " " say counter say
    counter inc counter store
    counter 4 cmp inctestloop jlte

    "\nNot 0: " say 0 not say "[br]" say
    "Not 1: " say 1 not say "[br]" say
    "Not 37: " say 37 not say "[br]" say
    "Not -9: " say -9 not say "[br]" say
    "Not \"Fred\": " say "Fred" not say "[br]" say
    "Not testMath: " say testMath not say "[br]" say
    "Not none: " say none not say "[br]" say

    continueStr showOptions add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test object property commands
// ////////////////////////////////////////////////////////////////////////////
function testObjectProps() {
    asm

    "\n# Testing object manipulation opcodes\n[b][testing get_prop][/b][br]" say
    "first_obj.aString: " say
    $aString first_obj get_prop say
    " (should be \"Hello World!\")[br]" say

    "first_obj.anInt: " say
    $anInt first_obj get_prop say
    " (should be 2)[br]" say

    "second_obj.aString: " say
    $aString second_obj get_prop say
    " (should be 0)[br]" say

    "\n[b][testing has_prop][/b][br]" say
    "first_obj has property anInt? " say
    $anInt first_obj has_prop say
    " (should be 1)[br]" say

    "second_obj has property aString? " say
    $aString second_obj has_prop say
    " (should be 0)[br]" say

    "\n[b][testing set_prop][/b][br]" say
    "setting second_obj.apple to \"Fred\"[br]second_obj.apple now equals " say
    "Fred" $apple second_obj set_prop
    $apple second_obj get_prop say

    "\n[b][testing property types][/b]" say
    "[br]first_obj.anInt (1): "      say $anInt      first_obj get_prop typeof say
    "[br]first_obj.aString (2): "    say $aString    first_obj get_prop typeof say
    "[br]first_obj.aList (3): "      say $aList      first_obj get_prop typeof say
    "[br]first_obj.aMap (4): "       say $aMap       first_obj get_prop typeof say
    "[br]first_obj.testMethod (5): " say $testMethod first_obj get_prop typeof say
    "[br]first_obj.anObject (6): "   say $anObject   first_obj get_prop typeof say
    "[br]first_obj.aProperty (7): "  say $aProperty  first_obj get_prop typeof say

    continueStr showOptions add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Basic looping demo
// ////////////////////////////////////////////////////////////////////////////
function testLoopDemo(: counter theValue) {
    asm
// show a count up loop and calculate 2^10
    0 counter store
    1 theValue store
    loopstart:
    counter 1 add counter store
    2 theValue mult theValue store
    counter say
    " " say
    counter 10 cmp loopstart jlt
    "Loop finished!\n" say
    "Final result: " say
    theValue say
    "\n" say

    continueStr showOptions add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test input commands
// ////////////////////////////////////////////////////////////////////////////
function testInputs() {
    asm
    "This node serves as a test of the menu selection options. Other input options can be selected in the menu below, or you can return to the top level menu." say
    "Test key input"        testGetkey     add_option
    "No extra value"        receiveExtra   add_option
    "Extra value 6"         receiveExtra   6   add_option_x
    "Extra value 73"        receiveExtra   73  add_option_x
    "Return to top menu"    showOptions    add_option
    dispatcher get_option
}
function receiveExtra(extra) {
    asm
    "Option extra value: " say extra say
    continueStr testInputs add_option
    dispatcher get_option
}
function testGetkey() {
    asm
    "This will demonstrate and test the get_key input type." say
    "Try pressing a key." testGetkeyReceive get_key
}
function testGetkeyReceive(key) {
    asm
    "Resulting character code: " say key say ".\n" say
    continueStr testInputs add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test value types
// ////////////////////////////////////////////////////////////////////////////
function testValues(: localvar unusedvar) {
    asm

    "int value: " say testInt typeof say
    testInt typeof Integer cmp int_bad jnz
    " good[br]" say tst_string jmp
    int_bad: " wrong[br]" say

    tst_string:
    "string value: " say testStr typeof say " " say
    testStr typeof String cmp string_bad jnz
    " good[br]" say tst_list jmp
    string_bad: " wrong[br]" say

    tst_list:
    "list value: " say testList typeof say " " say
    testList typeof List cmp list_bad jnz
    " good[br]" say tst_map jmp
    list_bad: " wrong[br]" say

    tst_map:
    "map value: " say testMap typeof say " " say
    testMap typeof Map cmp map_bad jnz
    " good[br]" say tst_function jmp
    map_bad: " wrong[br]" say

    tst_function:
    "function value: " say testFunction typeof say " " say
    testFunction typeof Function cmp function_bad jnz
    " good[br]" say tst_function_2 jmp
    function_bad: " wrong[br]" say
    tst_function_2:
    "value function aliasing:" say
    testFunction testFunctionName cmp tst_function_2_bad jnz
    " good[br]" say tst_obj jmp
    tst_function_2_bad: " wrong[br]" say

    tst_obj:
    "object value: " say testObject typeof say " " say
    testObject typeof Object cmp obj_bad jnz
    " good[br]" say tst_obj_2 jmp
    obj_bad: " wrong[br]" say
    tst_obj_2:
    "value object aliasing:" say
    testObject testObjectName cmp test_obj_2_bad jnz
    " good[br]" say tst_prop jmp
    test_obj_2_bad: " wrong[br]" say

    tst_prop:
    "property value: " say testProperty typeof say " " say
    testProperty typeof Property cmp prop_bad jnz
    " good\n" say tst_local jmp
    prop_bad: " wrong\n" say

    tst_local:
    "[b][setting local variable \"localvar\" to 57][/b][br]" say
    57 localvar store
    "local variable value: (" say localvar say ") " say localvar typeof say " " say
    localvar typeof Integer cmp local_bad jnz
    " good[br]" say tst_unused jmp
    local_bad: " wrong[br]" say

    tst_unused:
    "unused local value: (" say unusedvar say ") " say
    unusedvar typeof say " " say
    unusedvar typeof None cmp unused_bad jnz
    " good[br]" say tst_jump jmp
    unused_bad: " wrong[br]" say

    tst_jump:
    "jump target value: " say tst_jump typeof say
    tst_jump typeof Label cmp label_bad jnz
    " good\n" say all_done jmp
    label_bad: " wrong\n" say

    "[b][type coercion][/b][br]" say
    7 localvar store
    "Initial value: " say localvar say " and type: " say localvar typeof say "[br]" say
    String localvar astype localvar store
    "New value: \"" say localvar say "\" and type: " say localvar typeof say "[br]" say

    all_done:
    continueStr showOptions add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Output command tests
// ////////////////////////////////////////////////////////////////////////////
function testOutput() {
    asm

    "This text (and nearly all text in these tests) is output using the \"say\" command.\nSay integer value: " say
    6215 say
    "[br]-1 using say_unsigned (should be 4294967295): " say
    -1 say_unsigned
    "[br] using say_char (should be 'A'): " say
    65 say_char
    "[br]Say UTF-8 Text: テキストの例\n" say

    "# Testing text formatting:\n" say
    "bold text: [b]Lorem ipsum dolor sit amet.[/b][br]" say
    "italic text: [i]Lorem ipsum dolor sit amet.[/i][br]" say
    "bold italic: [b][i]Lorem ipsum dolor sit amet.[/i][/b][br]" say
    "italic bold: [i][b]Lorem ipsum dolor sit amet.[/b][/i]\n" say

    continueStr showOptions add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Update info areas
// ////////////////////////////////////////////////////////////////////////////
function testInfoarea() {
    asm

    "The header, footer, and title regions should now be updated. (Unless you already ran this test since starting the program.)" say

    "Good day!"     InfobarLeft     set_info
    "5:00 am"       InfobarRight    set_info
    "Fred is Cool"  InfobarFooter   set_info
    "Updated Title" InfobarTitle    set_info
    continueStr showOptions add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Test RNG
// ////////////////////////////////////////////////////////////////////////////
function testRandom(: counter) {
    asm

    "This will generate 100 random numbers between 50 and 60 below.\n" say

    100 counter store
    loop_start:
    counter loop_done jlte
    50 60 random say " " say
    counter 1 sub counter store
    loop_start jmp
    loop_done: "\n" say

    continueStr showOptions add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Test List Methods
// ////////////////////////////////////////////////////////////////////////////
function printArray(theArray : counter length) {
    asm

    "[b]Array contents:[/b]" say
    theArray get_size length store
    0 counter store
    arraydumploop:
    " " say counter theArray get_item say
    counter inc counter store
    length counter cmp arraydumploop jgt
    " (length: " say length say ")\n" say
}

function testLists(: counter) {
    asm

    "Test list size (should be 3): " say
    testList get_size say "\n" say
    testList 1 printArray call

    "Adding new item 91 at end...\n" say
    91 99 testList add_item "\n" say
    testList 1 printArray call

    "Adding new item 4608 in first position...\n" say
    4608 0 testList add_item "\n" say
    testList 1 printArray call

    "Adding new item 44 after second item...\n" say
    44 2 testList add_item "\n" say
    testList 1 printArray call

    "New test list size (should be 6): " say
    testList get_size say "\n" say

    "Deleting index #2...\n" say
    2 testList del_item
    testList 1 printArray call

    "Trying to get bad index -1: " say
    -1 testList get_item say "\n" say

    "Trying to get bad index 99: " say
    99 testList get_item say "\n" say

    "Updating index #2 to second_obj...\n" say
    second_obj 2 testList set_item
    testList 1 printArray call

    "\nSelecting 20 random items from testList:" say
    0 counter store
    randomloop:
    " [" say testList get_random say "]" say
    counter inc counter store
    20 counter cmp randomloop jgt

    continueStr showOptions add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Test Map Methods
// ////////////////////////////////////////////////////////////////////////////
function testMaps(: keys) {
    asm

    "Current item \"7\" (non-existant key): " say
    7 testMap get_item say
    "[br]" say


    "Current item \"2\" (\"End\"): " say
    2 testMap get_item say
    "\n" say

    "Updating item \"2\"...[br]" say
    "Apple" 2 testMap set_item

    "New item \"2\" (\"Apple\"): " say
    2 testMap get_item say
    "\n" say


    "Adding item \"item\"...[br]" say
    "newkey" "item" testMap set_item

    "Item \"item\" value (\"newkey\"): " say
    "item" testMap get_item say
    "[br]" say


    "Has key 2 (yes): " say
    2 testMap has_item say
    "\n" say

    "Deleting item \"2\"...[br]" say
    2 testMap del_item
    "Current item \"2\" (\"End\"): " say
    2 testMap get_item say "\n" say

    "Has key 2 (no): " say
    2 testMap has_item say
    "[br]" say


    "Has key 3 (yes): " say
    3 testMap has_item say
    "[br]" say

    "Has key 88 (no): " say
    88 testMap has_item say
    "\n" say

    testMap get_keys keys store
    "Converting testMap keys to list...[br]" say
    keys 1 printArray call

    continueStr showOptions add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Test Page Commands
// ////////////////////////////////////////////////////////////////////////////
function testPages() {
    asm
    "Demo Page" testPage1 'd' add_page
    "Another Page" otherPage 'a' add_page
    "Page" otherPage 'p' add_page
    "A Long Page Name" otherPage 'l' add_page
    0 testPagesReal call
}
function testPagesReal() {
    asm
    "Extra pages have been added and can be activated by hotkey or by clicking on their button in the lower left." say
    "Remove \"Another Page\"" testPagesRemovePage add_option
    continueStr testPagesCleanup add_option
    dispatcher get_option
}
function testPagesRemovePage() {
    asm
    "Another Page" del_page
    0 testPagesReal call
}
function testPagesCleanup() {
    asm
    "Demo Page" del_page
    "Another Page" del_page
    "Page" del_page
    "A Long Page Name" del_page
    0 showOptions call
}

object testpageData
    count 1
    index 0
;
function testPage1(key) {
    asm
    key typeof Integer cmp showpage jnz
    key 32 cmp showkey jnz
    end_page
    return

    leftkey:
    $index testpageData get_prop dec $index testpageData set_prop
    showpage jmp
    rightkey:
    $index testpageData get_prop inc $index testpageData set_prop
    showpage jmp
    upkey:
    $index testpageData get_prop 10 mult $index testpageData set_prop
    showpage jmp
    downkey:
    $index testpageData get_prop 10 div $index testpageData set_prop
    showpage jmp

    showkey:
    "You pressed: " say key say " (which is not space).\n" say
    key -1 cmp leftkey jz
    key -2 cmp rightkey jz
    key -3 cmp downkey jz
    key -4 cmp upkey jz
    showpage:
    "You have viewed this page " say
    $count testpageData get_prop say
    " times. The index counter is " say
    $index testpageData get_prop say
    ". Use arrow keys to change."
    "Press space to return." testPage1 get_key
    $count testpageData get_prop inc $count testpageData set_prop
}
function otherPage() {
    asm
    "You selected a page other than the demo page! (Only the demo page has actual content.)" say
    continueStr testPagesCleanup add_option
    endOtherPage get_option
}
function endOtherPage() {
    asm end_page
}

function testDynamic(: newObj newStr newList newMap) {
    asm

    "[b]Creating data...[/b][br]" say

    "[i]Creating new object...[/i][br]" say
    Object new newObj store
    "Created type:" say newObj typeof say "[br]" say

    "Initial anInt property: " say
    $anInt newObj get_prop say "[br]" say
    66 $anInt newObj set_prop
    "anInt property after update: " say
    $anInt newObj get_prop say "\n" say

    "[i]Creating new string...[/i][br]" say
    String new newStr store
    "Created type:" say newStr typeof say "[br](string manipulation functions tested seperately)\n" say

    "[i]Creating new map...[/i][br]" say
    Map new newMap store
    "Created type:" say newMap typeof say "[br]" say
    "Initial value of key: " say "key" newMap get_item say "[br]" say
    "New Map Value" "key" newMap set_item
    "Updated value of key: " say "key" newMap get_item say "\n" say

    "[i]Creating new list...[/i][br]" say
    List new newList store
    "Created type:" say newList typeof say "[br]" say
    "Initial size: " say newList get_size say "[br]" say
    "New List Item" 0 newList add_item
    "New size: " say newList get_size say "[br]" say
    "Item 0: " say 0 newList get_item say "\n" say

    "[b]Testing isStatic[/b][br]" say
    "testDynamic (1): " say testDynamic is_static say "[br]" say
    "\"Fred\" (1): " say "Fred" is_static say "[br]" say
    "testList (1): " say testList is_static say "[br]" say
    "newObj (0):" say newObj is_static say "[br]" say
    "newStr (0):" say newStr is_static say "\n" say

    List new List new List new say

    continueStr testPagesCleanup add_option
    dispatcher get_option
}

// ////////////////////////////////////////////////////////////////////////////
// Test selection
// ////////////////////////////////////////////////////////////////////////////
function showOptions() {
    asm

    "Welcome to the feature test demo!\nSelect one of the options displayed below by entering its associated number in order to run the tests. When that is complete, you will be returned to this screen." say

    "Loop Demo"                 testLoopDemo       add_option
    "Test Info Areas"           testInfoarea       add_option
    "Test Pages"                testPages          add_option
    "Test Call"                 testCall           add_option
    "Test Dynamic Objects"      testDynamic        add_option
    "Test RNG"                  testRandom         add_option
    "Test Compare"              testCompare        add_option
    "Test Jumps"                testJumps          add_option
    "Test Math"                 testMath           add_option
    "Test List Methods"         testLists          add_option
    "Test Map Methods"          testMaps           add_option
    "Test Object Properties"    testObjectProps    add_option
    "Test Input Methods"        testInputs         add_option
    "Test stack commands"       testStack          add_option
    "Test value types"          testValues         add_option
    "Test output"               testOutput         add_option
    dispatcher get_option
}


function dispatcher(optionFunc extraValue) {
    asm

    extraValue 1 optionFunc call
    0 return
}

function main() {
    asm

    "GTRPGE Test Suite" InfobarTitle set_info
    0 showOptions call
}

value te "";
